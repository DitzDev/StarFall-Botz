const cluster = require('cluster'), path = require('path'), fs = require('fs'), package = require('./package.json'), CFonts = require('cfonts'), Readline = require('readline'), yargs = require('yargs/yargs')
const readline = Readline.createInterface(process.stdin, process.stdout)

CFonts.say(`StarFall-Botz`, {
   font: 'tiny',
   align: 'center',
   colors: ['system']
})
CFonts.say(`Nguwawur cik`, {
   font: 'console',
   align: 'center',
   colors: ['system']
})

var isRunning = false
/**
 * Start a js file
 * @param {String} file `path/to/file`
 */
async function start(file) {
   try {
      if (isRunning) return;
      isRunning = true;
      let args = [path.join(__dirname, file), ...process.argv.slice(2)];
      cluster.setupMaster({
         exec: path.join(__dirname, file),
         args: args.slice(1),
      });
      let p = cluster.fork();
      p.on('message', data => {
         console.log('[RECEIVED]', data);
         switch (data) {
            case 'reset':
               p.process.kill();
               isRunning = false;
               start.apply(this, arguments);
               break;
            case 'uptime':
               p.send(process.uptime());
               break;
         }
      });
      p.on('exit', (_, code) => {
         isRunning = false;
         console.error('Exited with code:', code);
         if (code === 0) return;
         fs.watchFile(args[0], () => {
            fs.unwatchFile(args[0]);
            start(file);
         });
      });
      let opts = new Object(yargs(process.argv.slice(2)).exitProcess(false).parse());
      if (!opts['test'])
         if (!readline.listenerCount()) readline.on('line', line => {
            p.emit('message', line.trim());
         });
   } catch (error) {
      console.error(error);
   }
}
start('main.js')